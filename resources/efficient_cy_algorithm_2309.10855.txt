Efficient Algorithm for Generating
Homotopy Inequivalent Calabi-Yaus
Nate MacFaddena

arXiv:2309.10855v2 [hep-th] 21 Sep 2023

a

Department of Physics, Cornell University, Ithaca, NY 14853 USA

Abstract

We present an algorithm for efficiently exploring inequivalent Calabi-Yau threefold hypersurfaces in toric varieties. A direct enumeration of fine, regular, star triangulations
(FRSTs) of polytopes in the Kreuzer-Skarke database is foreseeably impossible due to
the large count of distinct FRSTs. Moreover, such an enumeration is needlessly redundant because many such triangulations have the same restrictions to 2-faces and hence, by
Wall’s theorem, lead to equivalent Calabi-Yau threefolds. We show that this redundancy
can be circumvented by finding a height vector in the strict interior of the intersection of
the secondary cones associated with each 2-face triangulation. We demonstrate that such
triangulations are generated with orders of magnitude fewer operations than the naı̈ve
approach of generating all FRSTs and selecting only those differing on 2-faces. Similar
methods are also presented to directly generate (the support of) the secondary subfan of
all fine triangulations, relevant for random sampling of FRSTs.

Contents
1 Introduction

2

2 The ‘mod’ approach

3

3 On-demand generation
3.1 Regularity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Applied to NTFE FRSTs . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 Benchmarks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6
6
9
10

4 Secondary subfan

13

5 Conclusion

15

6 Acknowledgements

16

A Verification of algorithm 2
A.1 coni(G)∗ ⊆ coni(H)∗ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A.2 coni(G) ⊆ coni(H) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

18
18
19

1

1

Introduction

In order to understand quantum gravity, it is important to study compactifications of
string theory. One way to do this is by studying Calabi-Yau threefold hypersurfaces in
toric varieties (CYs). The natural object of interest, then, is the Kreuzer-Skarke database
(KS) [1], a complete collection of all 473, 800, 776 4D reflexive polytopes. This is because
KS defines the largest known number of CYs: any fine, regular, star triangulation (FRST)
of any polytope in KS specifies the topological data defining a CY. Briefly, these adjectives
mean
(a) ‘fine’ =⇒ every lattice point in the polytope is a vertex of at least one simplex in
the triangulation,
(b) ‘regular’ =⇒ the triangulation can be constructed following the procedure laid out
in section 3.1, and
(c) ‘star’ =⇒ the origin is a vertex of every simplex in the triangulation.
The reasons for imposing such restrictions are discussed in detail in [2].
Brute-force approaches to enumerate this population of CYs (i.e., generate all FRSTs,
map to their associated CYs) are limited primarily by the count of FRSTs: NFRST <
1.53 × 10928 [2]. Fortunately, as is shown in [2], this collection of CYs is very redundant:
topologically equivalent CYs define physically equivalent solutions of string theory and, by
Wall’s theorem [3], any two FRSTs, T1 and T2 , of a polytope ∆ ∈ KS with the same 2face restrictions generate topologically equivalent CYs. Thus, it is sufficient to study only
FRSTs with unique 2-face restrictions, hereon denoted ‘NTFE’ for ‘non-2-face-equivalent’.
There are “only” NNTFE < 1.65 × 10428 [2]1 NTFE FRSTs. The set of NTFE FRSTs
still contains redundancies due to non-trivial basis transformations mapping CYs into
one-another, thus providing hope for even smaller counts of inequivalent CYs, but those
redundancies will be harder to deal with - we do not concern them in this work.
There are two primary strategies to utilize this 500 order-of-magnitude redundancy:
(a) (the ‘mod approach’) generate all FRSTs and then mod out by 2-face equivalence
before running any of the expensive CY calculations or
(b) (the ‘on-demand approach’) somehow directly generate NTFE FRSTs.
1

With some work, one can tighten the bound on NNTFE significantly, from both sides [4]. Exact bounds
are not quoted here (no spoilers!) but, for a teaser, the upper bound drops by > 50 orders of magnitude.

2

The mod approach, used in numerous studies such as [5–7], is nice because it is both simple
and enables order-of-magnitude speedups over the aforementioned ‘brute-force’ algorithm.
However, as we discuss in section 2, the mod approach is ultimately limited by the large
count of FRSTs. For example, the largest h1,1 -value for which one can generate all FRSTs
of a typical polytope (in reasonable time on a modern personal computer) is h1,1 ≲ 10.
This is true even if the count of NTFE FRSTs of said polytope is relatively small, such
that the subsequent CY-focused calculations are relatively quick.
The difficulty in generating all FRSTs motivates the on-demand approach: if one could
directly generate NTFE FRSTs, the (highly redundant) count of all FRSTs would become
irrelevant. Before this paper, as far as the author knows, there was no known method for
such direct enumeration. However, as we show in section 3, such direct generation can be
achieved both simply and efficiently. In brief, one can (efficiently) either directly generate
an FRST with user-specified 2-face restrictions or prove that no such FRST exists. This
on-demand generation algorithm is the main result of this paper.
Finally, in section 4, we provide an adaptation of the on-demand NTFE algorithm. This
adaptation, instead of generating FRSTs, generates an object called the ‘support of the
secondary subfan of fine triangulations’. Roughly, this is an object describing all NTFE
FRSTs of a given polytope, even when direct enumeration is infeasible (e.g., for polytopes
with h1,1 ≳ 100). The provided algorithm both provably generates the desired cone and
it does so very quickly: the run time for even the largest polytope (h1,1 = 491) is only
< 1min on modern personal computers. Run time is even quicker for smaller ∆ ∈ KS. (A
variant of) this subfan has already been used successfully for fairly sampling FRSTs [2],
and more algorithms are currently being developed to further utilize it.

2

The ‘mod’ approach

As we have seen, the population of physical interest when studying CYs from KS is that of
NTFE FRSTs. The most direct method of enumerating only the NTFE FRSTs of a given
polytope ∆ ∈ KS is by generating all FRSTs and then modding out by 2-face equivalence.
A nice way to visualize this procedure is through the use of the (bistellar) flip graph of
∆. This is the graph in which nodes represent FRSTs and edges represent bistellar flips
between the FRSTs. Such graphs can naı̈vely be viewed as a portion of the string landscape
- each node representing a solution of string theory.
In terms of flip graphs, the modding-out procedure is simply contracting nodes if they

3

Figure 1: Left: the flip graph of the 0th polytope in KS (lattice N) with h1,1 = 5, colored
by 2-face equivalence. Right: after contracting by 2-face equivalence, only 2 nodes out of
the original 142 survive.
have the same 2-face restrictions2 . For example, consider the flip graph of the 0th polytope
in KS (lattice N) with h1,1 = 53 , plotted on the left side of fig. 1. This graph has N = 142
nodes but, after modding out by 2-face equivalence, only N = 2 of them survive (see right
side of fig. 1). Since
(a) all 2-face equivalent nodes represent physically-identical solutions of string theory,
(b) the NTFE flip graphs (i.e., the flip graphs after contraction) are typically much
smaller than the FRST flip graphs (as we will soon argue more generally), and
(c) it is relatively cheap to mod out by 2-face equivalence,
it is clearly preferable to always perform this modding out before carrying out any expensive computations on the CYs. In other words, while the left side of fig. 1 is the naı̈ve,
initial estimate of some region of the landscape, it actually contains many copies of the
same physical solutions! When one takes Wall’s theorem into consideration, the landscape
collapses to something much smaller.
While the reduction in fig. 1 is sizeable, it is actually very modest compared to the gains
achievable in KS. This is primarily due to the small value of h1,1 : even marginal increases in
h1,1 cause significant increases in the reduction from all FRSTs to only the NTFE FRSTs.
For example, the 0th polytope with h1,1 = 8 contains only N = 4 NTFE FRSTs despite
2

It is not hard to see that the subgraph of FRSTs that are 2-face equivalent to some triangulation, T ,
is connected. Thus, contraction is indeed the same as modding-out.
3
The lattice points defining this polytope are (−2, 2, 1, −1), (−1, 1, 1, 0), (0, −1, −1, 0), (0, 0, 0, 0),
(0, 0, 0, 1), (0, 0, 1, 0), (0, 1, 0, 0), (1, −2, 1, 1), (1, 0, 0, 0), and (1, 1, −1, −1).

4

11928

# FRSTs / poly
# NTFEs / poly

fit upper bounds

11773
11618
11464
11309
11154
110
0

70

140

210

280

350

420

491

h 1,1

Figure 2: (Data/fits from [2]). Approximate bounds on the number of FRSTs (blue;
1,1
1,1
N ≲ 10−5.31 101.91 h ) and the number of NTFEs (yellow; N ≲ 10−15.45 100.90 h ) per
∆ ∈ KS, as a function of h1,1 . While both bounds scale exponentially with h1,1 , the bound
on FRSTs grows exponentially quicker than that on NTFEs.
having N = 1171 FRSTs. As h1,1 further increases, this redundancy of FRSTs (when the
real population of interest are the NTFE FRSTs) grows rapidly. Even at relatively small
values of h1,1 (such as 10), the enumeration of all FRSTs can be prohibitive in time and
memory. This growing redundancy will be demonstrated in detail in section 3.3.
This scaling with h1,1 could have been anticipated by the bounds [2] on the count of
(NTFE) FRSTs for any single polytope in KS:
1,1

# FRSTs/poly ≲ 10−5.31 101.91 h

1,1

and

# NTFE FRSTs/poly ≲ 10−15.45 100.90 h ,

(2.1)
(2.2)

plotted in fig. 2. If the bound on # FRSTs/poly is not exponentially loose, then there is
an exponentially-increasing redundancy of FRSTs over NTFE FRSTs. This redundancy
ultimately limits the mod approach: quickly with h1,1 , the cost of generating all FRSTs
(only to throw out most of them) limits the scope of the study.
Clearly, it would be greatly beneficial to directly generate the NTFE FRSTs, rather
than stepping through all FRSTs. This would maintain the speedup of having fewer costly

5

operations on CYs, but it would achieve the additional speedup in reduced4 generation
of topologically equivalent CYs in intermediate steps. In terms of flip graphs, the goal is
to directly generate the nodes of the graph after contraction (right side of fig. 1). In the
following section, we demonstrate how to do this.

3

On-demand generation

In this section, we demonstrate how to generate NTFE FRSTs ‘on-demand’. This discussion leans on regularity, so we must first recall some definitions and notation.

3.1

Regularity

Let A = {p1 , . . . , pn } be a set of points pi ∈ Rd and let pi j be the jth coordinate of pi . A
triangulation of A is called ‘regular’ if it is obtainable via5 :
(a) ‘lifting’ each point pi by some height hi : pi → p̃i = (pi 1 , . . . , pi d , hi ) and
(b) projecting out the final coordinate of the ‘lower faces’ (those whose outwards-facing
normal vectors have a negative (d + 1)st component) of C = conv ({p̃0 , . . . , p̃n }).
For an illustration of this lifting/projecting procedure for generating regular triangulations,
see fig. 3.
3.1.1

The secondary cone

The heights generating a given regular triangulation are not unique. For example, consider the point configuration A = {p1 , p2 , p3 , p4 } as in fig. 3. These points are lifted
by heights h1 = 1.1, h2 = 0.2, h3 = 0.9, and h4 = 0.3, resulting in the convex hull
C = conv({p̃1 , p̃2 , p̃3 , p̃4 }), a 3-simplex. The lower faces of C are then outlined in blue,
corresponding to the regular triangulation plotted in black. Many different heights lead to
the same triangulation: for example, one is free to increase h1 and/or h3 (or, conversely,
decrease h2 and/or h4 ), without changing (the projection of) the lower faces of C.
4

‘Reduced’ since there still may be non-trivial basis transformations mapping CYs into one-another.
For small h1,1 , these equivalences are studied in detail in [8].
5
N.B.: Other definitions of regularity exist, but the one provided is most useful for current discussions.

6

p̃3
p̃1

p̃4
p4

p3
p̃2

p1

p2

Figure 3: The lifting of the point set A = {p1 , p2 , p3 , p4 } by heights h1 = 1.1, h2 = 0.2,
h3 = 0.9, and h4 = 0.3. The convex hull of the lifted point set, Ã, is a 3-simplex whose
lower two faces are plotted in blue. Projecting out the lifted coordinate generates the
regular triangulation plotted in black.
To understand the space of heights that are allowed for a given triangulation, T , organize the heights in a vector6 , h = (h1 , . . . , hn ), called the ‘height vector’ living in ‘height
space’. E.g., the height vector associated to fig. 3 is h = (1.1, 0.2, 0.9, 0.3). It is not difficult to show7 that the collection of all height vectors generating the same triangulation, T ,
forms the interior of a polyhedral cone called the ‘secondary cone’ [9]. That is, h, generates
the triangulation, T , if and only if h is in the strict interior of T ’s secondary cone.
The secondary cone is most directly represented in H-representation for which, in 2D,
the inwards-facing defining hyperplane inequalities, H, may be calculated as in algorithm 1
[10]8 . For example, following this algorithm, one finds a single hyperplane inequality
associated to fig. 3: h2 + h4 ≤ h1 + h3 . Any heights strictly obeying this inequality
generate the displayed triangulation. This matches intuition: all that matters in this case
is that every interior point of the line (p̃2 , p̃4 ) is below the corresponding point in either
conv({p̃1 , p̃2 , p̃3 }) or in conv({p̃1 , p̃3 , p̃4 }).
6

Since vectors are ordered, a choice of point ordering must be made. We will (arbitrarily) always
choose the order in which the point configuration is written on the page.
7
Here is a brief argument: note that, if h generates a triangulation T , then so does c h for any c > 0.
Likewise, if g also generates T , then it is not hard to see that h + g generates T .
8
In fact, as seen in appendix A, the explicit null-space calculations used in this algorithm are not
necessary. The null-spaces can be identified by simply counting points.

7

Algorithm 1 secondary cone
let H be an empty array
for adjacent simplices {pn1 , ps1 , ps2 } and {pn2 , ps1 , ps2 } do
let I = [s1, s2, n1, n2]


pI[0] pI[1] pI[2] pI[3]
for column c ∈ null
do
1
1( 1
1
let n be a vector with ni =

cj
0

i = I[j]
otherwise

if nI[2] < 0 then
append (−n)T to H
else
append nT to H
end if
end for
end for
return H
3.1.2

Multiple secondary cones

Consider the case of multiple point configurations, A1 , . . . , An , with corresponding regular
triangulations T1 , . . . , Tn . As we have discussed, due to regularity, each of these triangulations Ti can be generated by a height vector, hi . Stronger, a height vector, hi , generates Ti
if and only if Hi hi > 0, where the rows of Hi are the inwards-facing hyperplane normals
defining Ti ’s secondary cone.
S
Consider the union A = ni=1 Ai . We want a height vector, h, which ‘simultaneously
generates’ all triangulations T1 , . . . , Tn . By that, we mean: let Πi be a projection matrix
from the height space associated to A to that associated with Ai . Then, we seek an h such
that Hi (Πi h) > 0 for all i. Define



H1 Π1
 . 
. 
H=
 . .
Hn Πn

(3.1)

This object makes sense because each Hi Πi object has width |A|, and thus can be vertically
stacked. Thus, the goal9 is an h such that H h > 0. This is trivially done with linear
programming.
9

Note: it is OK to embed in an even higher dimensional space. By doing so, one is simply introducing
more points in A. The heights of these ‘extra’ points will simply not be constrained by H.

8

3.2

Applied to NTFE FRSTs

The application of section 3.1.2 to the study of NTFE FRSTs will be direct, but we first
must make some observations:
(a) Fineness with respect to all points is not necessary for the CY. Instead, all that is
necessary is fineness with respect to points appearing on 2-faces of the polytope [11].
(b) Any non-star, regular triangulation can be converted into a star triangulation without
affecting the 2-face triangulations. This is simply by lowering the height of the origin
until it appears in all simplices. Thus, the ‘star’ requirement is semi-ignorable.
Thus, all one needs to do is generate fine, regular triangulations, where ‘fine’ will hereon
mean ‘fine with respect to 2-faces’. We will denote such triangulations as ‘FR(S)Ts’, to
emphasize that they are not truly star, but that there is a direct procedure to convert
them to a star triangulation without affecting the 2-faces. Those triangulations that are
genuinely star will still be denoted as FRSTs.
With these notes, the procedure in section 3.1.2 is exactly what we need: if one lets
(a) A be the point set of the polytope of interest,
(b) Ai be the point set of each 2-face (in an arbitrary 2D basis),
(c) Πi be the projection from the ordering of A to Ai , and
(d) Hi be the (inwards facing) hyperplane inequalities of each 2-face’s secondary cone,
then direct application of section 3.1.2 generates NTFE FR(S)Ts on-demand. This is the
main result of this paper.
This calculation has a simple geometric interpretation. The objects Hi Πi each represent
the embedding Ti ’s secondary cone in the height space of A. By vertically stacking such
Hi Πi , we are taking the intersection of such cones. Thus, H is just the intersection of all 2face secondary cones. This is effectively equivalent to the problem of finding a height vector
associated to an FRST, except we have dropped all hyperplane inequalities constraining
points not on 2-faces.
It is important to stress: this algorithm, the main result, follows from three crucial
observations:
(a) CYs only require fineness on 2-faces,
9

(b) the height of the origin is ignorable in intermediate steps, and
(c) by Wall’s theorem, only FRSTs with distinct 2-faces are physically relevant.
Together, these observations suggest that, when constructing toric solutions to string
theory from KS, one loses nothing by restricting attention to 2-faces. The other
points do contain information (especially the origin), but those points are not needed for
specifying NTFEs and said information is recoverable. Needless to say, 2D polytopes/triangulations are much easier to handle than 4D ones.

3.3

Benchmarks

The entire purpose of the on-demand algorithm is its efficiency, so we provide some benchmarks against the mod algorithm. Note that the mod algorithm comprises two steps:
generating all FRSTs and then modding out by them. Thus, it suffices to show that the
on-demand algorithm is more efficient than just the step of generating all FRSTs.
To directly generate NTFE FRSTs, we implement the on-demand algorithm in Python,
using the CYTools [12] framework. To generate all FRSTs, we use TOPCOM [13] (specifically, the CYTools wrapper for this software). Note: TOPCOM is a sophisticated software,
written in C++, that has been developed for nearly 20 years. The on-demand implementation, in contrast, is written in ∼weeks in Python and has had relatively little optimization.
Despite these serious handicaps, we will see that the on-demand algorithm achieves order
of magnitude speedups (and memory reduction) when compared to TOPCOM’s high bar.
To compare the two algorithms, we generate all FRSTs/NTFEs of the first 10 favorable
polytopes of KS (lattice N) for each 5 ≤ h1,1 ≤ 10. The total number of triangulations,
peak memory usage, and clock time for each h1,1 are all recorded. All calculations are done
in a Docker Image (8GB RAM) on a M1 Pro chip.
As is visible in table 1, the count of NTFEs and FRSTs both increase exponentially
with h1,1 , but NFRST increases exponentially quicker than NNTFE . In this benchmark,
enumeration of all FRSTs can only be performed for h1,1 ≤ 8 since it requires > 8 GB of
memory to enumerate all FRSTs of the selected polytopes with h1,1 ≥ 9. Contrast this to
the on-demand generation, which never requires more than 15 MB of memory, orders of
magnitude less than the mod algorithm.

10

1,1

h
5
6
7
8
9
10

NFRST
NNTFE
(TOPCOM) (CYTools)
201
14
1121
31
5111
53
28402
117
10
716
8289

MFRST [MB]
(TOPCOM)
1.8
94.6
775.9
5562.9
OOM
OOM

MNTFE [MB]
(CYTools)
< 0.01
< 0.01
< 0.01
< 0.01
0.06
14.7

TFRST [s]
TNTFE [s]
(TOPCOM) (CYTools)
1.7
2.4
19.8
3.2
118.5
3.3
810.8
4.5
12.0
95.1

Table 1: The number of FRSTs/NTFEs of the first 10 favorable polytopes (in KS ordering)
for each 5 ≤ h1,1 ≤ 10, along with the peak memory usage and the clock times needed
to calculate them. All calculations are performed in a Docker Image (8GB RAM) on a
M1 Pro chip. Counts: the counts NFRST and NNTFE both increase exponentially, but
NFRST increases exponentially quicker. Memory: the peak memory appears to increase
exponentially (as expected due to the exponentially increasing counts). Even at h1,1 = 8,
the memory load to generate all FRSTs is large (> 5GB); larger values of h1,1 lead to
crashes due to lack of memory (i.e., out-of-memory or ‘OOM’). The memory needed to
generate all NTFEs is negligible for all studied h1,1 . Time: while TOPCOM is quicker
than the on-demand algorithm at h1,1 = 5, this is likely just due to optimization/language
differences. At every other h1,1 , the on-demand algorithm is quicker, with an exponentially
increasing speedup as h1,1 increases.

This demonstrates the first, crucial, point: the on-demand algorithm requires much less
memory and thus can probe KS much deeper. For example, with the on-demand algorithm,
one can study all NTFE FRSTs for select11 polytopes with h1,1 = 20, such as is plotted in
fig. 4. Even though we did some extra work here (in calculating the adjacencies/edges), it
still only took < 2s to generate this graph. While this plot displays a small number (81)
of NTFEs, the associated number of FRSTs is too large to reasonably calculate on one’s
laptop - the mod algorithm has little hope of getting close to such h1,1 -scales.
The second, crucial, point is the speed: as is visible in table 1, the on-demand algorithm
is exponentially quicker than the mod-algorithm. For example, consider the largest h1,1
for which a comparison can be made: h1,1 = 8. Here, it only takes ∼ 4.5s to generate all
117 NTFEs of the first 10 polytopes, compared to the > 13.5min to generate the 28402
FRSTs. This speed of the on-demand algorithm (in addition to its minimal memory draw)
enables NTFE generation to become somewhat negligible. One can focus on the physics
questions at hand, rather than this technical step of generating the NTFEs.
10

Using more memory, one finds that NFRST = 256131 for the first 10 favorable polytopes at h1,1 = 9.
In fact, one can actually push up to h1,1 ≈ 30 but, at such h1,1 , it becomes increasingly unlikely that
a randomly chosen polytope will have few enough NTFE FRSTs.
11

11

Figure 4: The NTFE flip graph for the 0th polytope with h1,1 = 20. It is unlikely to calculate this graph (in reasonable time) using the methods of section 2; one needs section 3.2.
There are three notes of primary importance regarding the computational efficiency of
the on-demand algorithm:
(a) Currently, the on-demand algorithm is limited by the final step, using LP to find
points in cones. If one just cares about generating the relevant (intersected) cones,
then one can push studies much deeper - without further optimization, the on-demand
algorithm generates ∼ 700000 relevant cones per second (no checks for solid-ness in
this number). This takes very little memory.
(b) If not all NTFEs are needed, then one can either generate random 2-face triangulations to ‘extend’ to FR(S)Ts or generate all relevant cones (as above) and sample
from said cones. Both methods are significantly more efficient than the corresponding
methods of either the brute-force or mod algorithms. The first option (generating
random 2-face triangulationss) is preferred - timing/memory in this case is only limited by the number of points on 2-faces. Thus, the algorithm scales even to the
largest polytope, with h1,1 = 491.
(c) There is significant structure in the cone’s hyperplanes that is simply being ignored
12

by our use of an LP solver. E.g., all hyperplanes are sparse (at most 4 nonzero
elements), sum to 0, and come in one of three patterns (either consisting of elements
{−1, −1, 1, 1} or {−2N − 2, 1, 1, 2N } or {−2N − 3, 1, 1, 2N + 1} for N ∈ Z≥ ; see
appendix A).
Clearly, then, despite the on-demand algorithm having numerous handicaps, one finds
that it is much quicker than the mod algorithm. Further, we see that, if one can reformulate
questions in terms of the relevant cones, then nearly all computational difficulties regarding
generation of NTFEs become extremely negligible.

4

Secondary subfan

We have seen that secondary cones define the heights generating regular triangulations.
Following this, we studied the set of all secondary cones that could be associated with a
polytope, mod 2-face equivalence. This collection is formally a fan, specifically the fan of
all FR(S)Ts. It is conventional to view this as a subfan of only the fine triangulations of
the polytope, and the ‘full’ fan as being all (regular) triangulations of the polytope.
This object, in general, is quite complicated: for a polytope ∆ ∈ KS, the associated
secondary subfan is composed of # NTFE FR(S)Ts cones. For example, each polytope
with h1,1 = 462 has ≲ 10401 associated NTFE FR(S)Ts [2]. Resultantly, their associated
subfans would each be made of ≲ 10401 cones. Even if these bounds are exponentially
loose, the subfans are still comprised of an infeasible-to-count number of cones.
While such a complete description for generic polytopes is foreseeably impossible (it is
equivalent to enumerating all NTFE FR(S)Ts), it actually is not difficult to describe the
union of all such cones. This union is itself a polyhedral cone and it has the interpretation
that points in it generate fine, regular subdivisions of the polytope. In fact, except for
a measure-0 set (the boundaries between secondary cones), these height vectors generate
FR(S)Ts. Denote (the defining hyperplanes of) this union as G.
Our strategy for determining G will be analogous to the on-demand FRST algorithm
in section 3.2:
(a) for each 2-face, fi , of the polytope of interest, ∆,
(b) generate the associated cone defining the height-space of all fine triangulations, denoted Gi , and then

13

Algorithm 2 (support of the) secondary subfan of fine triangulations
let H be an empty array
# (linear constraints)
for {pi , pj } ⊂ A for which ∃!pr ∈ A 
such that pr ∈ int (conv({pi , pj })) do

l ∈ {i, j}
1
l
let n be a vector such that n = −2 l = r


0
otherwise.
append n to H
end for
# (planar constraints)
for {pi , pj , pk } ⊂ A for which ∃!pr ∈A such that pr ∈ int (conv({pi , pj , pk })) do

l ∈ {i, j, k}
1
l
let n be a vector such that n = −3 l = r


0
otherwise.
append n to H
end for
return H



G1 Π1
 . 
. 
(c) calculate G = 
 . .
Gn Πn
This algorithm works for the same reason that the on-demand FRST algorithm works: a
regular triangulation of ∆ is fine on all of its 2-faces if and only if it is fine on each 2-face.
A regular subdivison of a 2-face is fine if and only if the associated height vector is in Gi .
Such a technique allows us to restrict attention to 2D polytopes, for which the algorithm
follows simply (algorithm 2; verified in appendix A).
Thus, by simply evaluating algorithm 2, one can generate the support of the subfan of
fine triangulations of a given polytope. The only difficulty in this algorithm is finding the
subsets S ⊂ A for which the checks (i.e., exactly one point in the strict interior of S; no
non-vertices on boundary) apply. This comes down to evaluating the area of triangles and
checking if there are lattice points along a line segment. These operations may efficiently
be performed using the shoelace formula (+ Pick’s theorem) and checks on GCDs.
While this subfan is useful for sampling triangulations, as shown in [2], we do not make
further comments in this paper on its applications (other than that other algorithms using
it are currently being developed).

14

5

Conclusion

The Kreuzer-Skarke database is the largest known collection of Calabi-Yau threefold toric
hypersurfaces and our best hope for finding/constructing solutions of string theory with
physics similar to our world. Unfortunately, there seems to currently be no clear roadmap12
of where in KS to search for CYs with ‘interesting physics’. Thus, this wealth of solutions
actually raises a very serious computational obstacle: given that we likely can never study
every CY in KS, how might one find a CY similar to the real world?
This paper focused on the most direct response: colloquially, “just perform the calculations quicker by not stepping through an exponentially redundant set”. Specifically,
following Wall’s theorem, this paper demonstrated a simple algorithm (see section 3.2) for
either directly generating NTFE FR(S)Ts, or proving that no such FR(S)T exists. Despite
not being optimized, Python implementations of this algorithm (in CYTools [12]) were observed to be orders of magnitude faster than the algorithm laid out in section 2, matching
expectations (see fig. 2).
Following this, we demonstrated how to directly generate (the support of) the secondary
subfan of fine triangulations in section 4. Initial tests (not included) suggest that this
subfan can be used to sample orders-of-magnitude more NTFE FRSTs of the polytope
with h1,1 = 491 than previously achievable, but we do not present detailed discussion here.
Instead, algorithm 2 is provided since this subfan defines the ‘landscape’ of secondary
cones, and since it is extremely similar to algorithm 1.
There are many future directions for this study, some of which are direct:
(a) better utilize the structure of the hyperplanes when finding points in the relevant
cones,
(b) better understand when a set of 2-face triangulations is ‘extendable’ into an FR(S)T,
and
(c) further optimize the implementation of the main algorithm (section 3).
There are also larger scale directions, such as:
(a) reformulate string-theory questions into those relating the (intersections of) secondary cones,
12

Correlations have been observed but, as far as the author knows, there are no definitive answers to
questions like “where in KS should one search to find a dS vacuum?”

15

(b) further develop algorithms exploiting the secondary subfan of fine triangulations,
(c) look (especially in 2-face data) for structures/correlations relevant to physical quantities, and
(d) look for similar algorithms that cut out even more redundancies.
As one final note, despite KS presenting daunting computational challenges, we see that
there is much room to grow.

6

Acknowledgements

I would like to thank Liam McAllister and Naomi Gendler for their discussions that ultimately led me down this line of study, and their encouragement throughout it. Further,
I would like to thank Andres Rios-Tascon for his greatly enjoyable (and informative) conversations about secondary cones and algorithm 1. I would also like to thank Andreas
Schachner for his encouragement and willingness to always discuss such computational
topics. Finally, I would like to thank Jakob Moritz for his discussions about regular triangulations as represented in height space.
This work was funded in part by NSF grant PHY–2014071.

References
[1] M. Kreuzer and H. Skarke, “Complete classification of reflexive polyhedra in
four-dimensions,” Adv. Theor. Math. Phys. 4 (2000) 1209–1230,
arXiv:hep-th/0002240.
[2] M. Demirtas, L. McAllister, and A. Rios-Tascon, “Bounding the Kreuzer-Skarke
Landscape,” Fortsch. Phys. 68 (2020) 2000086, arXiv:2008.01730 [hep-th].
[3] C. T. C. Wall, “Classification problems in differential topology. v,” Inventiones
mathematicae 1 no. 4, (1966) 355–374. https://doi.org/10.1007/BF01389738.
[4] N. MacFadden and M. Stepniczka, “Bounding Calabi-Yau Threefolds at h1,1 = 491,”.
WIP.
[5] M. Demirtas, N. Gendler, C. Long, L. McAllister, and J. Moritz, “PQ axiverse,”
JHEP 06 (2023) 092, arXiv:2112.04503 [hep-th].
16

[6] N. Gendler, B. Heidenreich, L. McAllister, J. Moritz, and T. Rudelius, “Moduli
Space Reconstruction and Weak Gravity,” arXiv:2212.10573 [hep-th].
[7] N. Gendler, O. Janssen, M. Kleban, J. La Madrid, and V. M. Mehta, “Axion minima
in string theory,” arXiv:2309.01831 [hep-th].
[8] N. Gendler, N. MacFadden, L. McAllister, J. Moritz, R. Nally, A. Schachner, and
M. Stillman, “Counting Calabi-Yau Threefolds,”. WIP.
[9] J. A. Loera, J. Rambau, and F. Santos, Triangulations. Springer Berlin, Heidelberg,
2010.
[10] P. Berglund, S. Katz, and A. Klemm, “Mirror symmetry and the moduli space for
generic hypersurfaces in toric varieties,” Nuclear Physics B 456 no. 1, (1995)
153–204.
https://www.sciencedirect.com/science/article/pii/0550321395004342.
[11] A. P. Braun, C. Long, L. McAllister, M. Stillman, and B. Sung, “The hodge
numbers of divisors of calabi-yau threefold hypersurfaces,” 2017.
[12] M. Demirtas, A. Rios-Tascon, and L. McAllister, “Cytools: A software package for
analyzing calabi-yau manifolds,” 2022.
[13] J. Rambau, “Topcom: Triangulations of point configurations and oriented
matroids,” in Proceedings of the International Congress of Mathematical Software.
2002. http://www.zib.de/PaperWeb/abstracts/ZR-02-17.
[14] B. Reznick, “Lattice point simplices,” Discrete Mathematics 60 (1986) 219–242.
https://www.sciencedirect.com/science/article/pii/0012365X86900154.
[15] R. T. Rockafellar, Convex Analysis. Princeton University Press, Princeton, 1970.
https://doi.org/10.1515/9781400873173.

17

A

Verification of algorithm 2

In this section, we show that the output of algorithm 2, denoted H, defines the support
of the secondary subfan of fine triangulations. As argued in section 4, attention can be
limited to 2D cases - we will do so throughout this section13 . That is, we will show
coni(G)∗ = coni(H)∗ , where the conical hulls are taken over the rows of each matrix.

A.1

coni(G)∗ ⊆ coni(H)∗

Here, we show that the support of the secondary subfan of fine triangulations is contained
in the cone defined by H.
Proposition 1. coni(G)∗ ⊆ coni(H)∗ .
The proof of this proposition effectively is just a recognition of what the hyperplanes in
H mean. Recall that there are two types of hyperplanes in H (see algorithm 2 and fig. 5):
(a) ‘linear constraint’ → for every line segment {pi , pj } containing exactly 1 interior
point, pr , ensure that p̃3r ≤ q̃ 3 for the point q̃ ∈ conv({p̃i , p̃j }) with q̃ 1 = p̃1r and
q̃ 2 = p̃2r , and
(b) ‘plane constraint’ → for every triangle {pi , pj , pk } containing exactly 1 point, pr , in
its strict interior (and no other lattice points on the boundary), ensure that p̃3r ≤ q̃ 3
for the point q̃ ∈ conv({p̃i , p̃j , p̃k }) with q̃ 1 = p̃1r and q̃ 2 = p̃2r .
The latter constraint warrants a brief note: in algorithm 2, we implicitly use that pr =
(pi + pj + pk )/3. That is, that pr is the centroid of the triangle {pi , pj , pk }. This is always
true for 2D lattice triangles whose only non-vertex lattice point is in the strict interior [14].
Proof. Let h ∈ coni(G)∗ . That is, h is a height vector for A such that all points p̃ ∈ Ã
appear on some lower face of conv(Ã).
Assume that h ∈
/ coni(H)∗ . Thus, a line constraint and/or a plane constraint is violated.
That means, there is a lifted lattice point, p̃r , and another point q̃ such that q̃ 1 = p̃1r and
q̃ 2 = p̃2r but q̃ 3 < p̃3r . Thus, p̃r cannot be on a lower face, a contradiction.
13

So the G here is akin to Gi in the main text.

18

pj

pj

pi

pr

pr = (pi + pj )/2

pi

pk

Figure 5: Illustrations of the linear and planar constraints in algorithm 2.

A.2

coni(G) ⊆ coni(H)

Here, we show that the cone defined by H is contained in the support of the secondary
subfan of fine triangulations. We do so through use of the dual, instead showing that
coni(G) ⊆ coni(H). That is, we want to show that every hyperplane inequality of coni(G)∗
can be represented as the conical hull of hyperplane inequalities in coni(H)∗ . First, we
must understand what the hyperplane inequalities of coni(G)∗ look like.
P
Lemma 1. coni(G) ⊆ N
i=1 coni(HTi ), where HTi are the hyperplane inequalities associated
to the secondary cone of the ith FRST of the associated polytope.
Proof. Recall, G describes the union or, (in this case) equivalently, the sum of all secondary
cones:
N
N
[
X
∗
∗
coni(G) =
coni(HTi ) =
coni(HTi )∗ .
(A.1)
i=1

i=1

It is not hard to see [15, Corollary 16.4.2] that this is, equivalently

coni(G) =

N
X

!∗
∗

coni(HTi )

=

i=1

Thus
coni(G) =

N
\

N
\

coni(HTi ).

(A.2)

i=1

coni(HTi ) ⊆

i=1

N
X

coni(HTi ).

(A.3)

i=1

We use lemma 1 to reformulate our studies: instead of directly studying hyperplanes
in coni(G)∗ , we can instead study those in coni(HTi )∗ . We do so because there is a nice
19

pn1

...

pn1
Ti

ps1

ps2

Ti
ps1

Tj
pn2

pn1

Tj
pn2

ps2

Ti

...

ps2

ps1
Tj
pn2

Figure 6: The geometries of the simplices Ti and Tj defining the secondary cone inequalities.
These shapes are classified by where the dotted line, {pn1 , pn2 } lays. If it lays outside the
convex hull (left), then the case is called ‘two triangles’; if it lays on an edge of the convex
hull (center), then the case is called ‘one triangle’; otherwise (right), the case is called
‘parallelogram’.
characterization (algorithm 1) of the inequalities in coni(HTi )∗ . Explicitly, coni(HTi ) is generated by rays, each ray associated to a pair, Ti and Tj , of unimodular simplices sharing an
edge (see fig. 6). There are three brief notes warranting mention regarding the inequalities
associated to such Ti and Tj :
(a) for a given triangulation T , there is a single inequality in coni(HT )∗ associated to Ti
and Tj . This is because the rank of the matrix in algorithm 1 is 3,
(b) the inequalities in algorithm 1 are basis independent so, when calculating them, we
can always pick a lattice basis such that Ti ∩ Tj is horizontal and such that Ti also
has a vertical edge (exactly as in fig. 6), and
(c) for Tj to be unimodular p2n2 = p2s1 − 1 = p2s2 − 1. That is, Tj has a ‘height’ of 1.
From these notes, a simple lemma follows (see fig. 7):
Lemma 2. Any non-vertex lattice point p ∈ conv(Ti ∪ Tj ) has y-coordinate equal to p2s1
(equivalently, p2s2 ).
Proof. Take the aforementioned choice of basis ({ps1 , ps2 } is horizontal, {ps1 , pn1 } is vertical). Let y0 = p2s1 = p2s2 .
Then, as previously noted, all points (x, y) ∈ conv(Ti ∪ Tj ) obey y0 − 1 ≤ y ≤ y0 + 1.
Furthermore, the only point with y-coordinate equal to y0 − 1 is pn2 ; the only point with
y-coordinate equal to y0 + 1 is pn1 .
20

pn1

ps1

pn1

ps2

q1 q2

ps1

ps2

q1 q2

pn2

pn2

Figure 7: For two unimodular triangle Ti = {pn1 , ps1 , ps2 } and Tj = {pn2 , ps1 , ps2 } in a
lattice basis such that p2s1 = p2s2 and p1s1 = p1n1 , any non-vertex lattice point, p ∈ conv(Ti ∪
Tj ) must have p2 = p2s1 . I.e., it must lay on the (extended) line Ti ∩ Tj . There are then two
cases: there can be a lattice point on the interior of the line {pn1 , pn2 } (right) or not (left).
It will be beneficial to classify such inequalities (i.e., pairs of simplices Ti and Tj ) by
their shape and study them case-by-case. Recognize that such a pair of simplices is exactly
one of the following three classes:
(a) (right of fig. 6; ‘parallelogram’): conv(Ti ∪ Tj ) = Ti ∪ Tj and both diagonals are
strictly contained in the region Ti ∪ Tj ,
(b) (center of fig. 6; ‘one-triangle’): conv(Ti ∪ Tj ) = Ti ∪ Tj and one ‘diagonal’ is also an
edge of the region Ti ∪ Tj , or
(c) (left of fig. 6; a ‘two-triangles’): conv(Ti ∪ Tj ) ⊃ Ti ∪ Tj .
As we will immediately see, inequalities associated with the parallelogram case do not arise
in coni(G)∗ , while the other two do. It is not hard to see, however, that the other two
classes of inequalities are in coni(H). Since these classes of inequalities generate coni(G),
this then will show coni(G) ⊆ coni(H).
A.2.1

Parallelogram case

Begin with the parallelogram case (right side of fig. 6). There are no concerns about
fine-ness of points - each point is a vertex. The associated inequality just controls which
diagonal occurs (the solid line vs. the dashed line). Thus, since we are only concerned
with fineness, we expect that such inequalities do not occur in coni(G).
To show this, we split analysis into whether the diagonal is flippable (i.e., into another
regular triangulation) or not. First, consider the case that it is flippable, then the secondary
21

cones associated to these two regular triangulations share a facet (a ‘wall’). The inequality
associated with the parallelogram is normal to this wall and the two cones on either side
have opposite normal vectors (but not both). Thus, these normals are not contained in
coni(G) =

N
\

coni(HTi ).

(A.4)

i=1

Second, consider the case that the diagonal is not flippable. Let nTi ,Tj be the inequality
associated to the pair of triangles Ti and Tj . The diagonal not being flippable means that
there is no such h such that (HT \ nTi ,Tj ) h ≥ 0 and nTi ,Tj · h < 0. That is, the set of all
other inequalities, HT \ nTi ,Tj , implies that nTi ,Tj · h ≥ 0. Thus, explicit consideration of
this inequality is not necessary - it will be implied by the other cases (i.e., one and two
triangle(s)).
A.2.2

One-triangle case

Now, the one-triangle case. We will show that the inequality, n, associated to the center
of fig. 6 is just the linear constraint from algorithm 2 and fig. 5.
This follows simply from the fact that the null space is 1D and that



1
r ∈ {n1, n2}


nr = −2 r = s1



0
otherwise

(A.5)

spans this null space. There is a simple explanation as to why this n is just the same vector
calculated in algorithm 2: the line {p̃s1 , p̃s2 } occurs in conv(T̃i ∪ T̃j ) if and only if p̃s1 is on
or below the line {p̃n1 , p̃n2 }. Thus, this case is really the same as the linear constraint of
algorithm 2.
A.2.3

Two-triangles case

Now, the two-triangles case. We will show that the inequality, n, associated to the right
of fig. 6 can be written as a conical combination of linear and planar constraints from
algorithm 2. In contrast to the parallelogram and triangle case, this requires a little work.
Note: if the region conv(Ti ∪Tj ) only contained 4 lattice points (those labelled in fig. 6),
then the associated hyperplane normal is just the planar constraint of algorithm 2. Thus,

22

we focus on the case where there are 5+ points in this region. Note, by lemma 2, all of
these points, p, must have p2 = p2s1 = p2s2 . That is, we are considering cases exactly like
what is displayed in fig. 7.
Begin with the case where there is a lattice point on the interior of line {pn1 , pn2 } (right
side of fig. 7). In this case, algorithm 2 calculates the hyperplanes:
n1 n2 q1 q2

1
1 −2 0
0
0
1 −2

 

n1
0
0
0
1

 
 n2   0
0
0
0
 
H=
 ..  =  .
 .   ..


nN +1
0
0
0
0

0
0
0
0
0
0
0
0

q3
0
1
−2
1

...
···
···
···
···
...

qN
0
0
0
0

s1
0
0
0
0

0
0
0

···
···
···

1
−2
1

0
1
−2

s2

0
0


0

0

.. 
.


0

0

(A.6)

1.

Consider the conical combination
m = n1 +

N
+1
X

h
i
2(k − 1)nk = · · · = 1 1 0 · · · 0 −(2N + 2) 2N .

(A.7)

k=2

This spans the relevant null space:
p · m = (−2N, −1) + (0, 1) − 2(N + 1)(0, 0) + 2N (1, 0) = 0.

(A.8)

Since the null space is 1D, we have thus shown that (in this case), the m ∈ coni(HTi ) is
expressible as a conical combination of n ∈ coni(H).
Now, the case where there is not a lattice point on the interior of line {pn1 , pn2 } (left

23

side of fig. 7). In this case, algorithm 2 calculates the hyperplanes:
n1 n2 q1 q2

1
1 −3 1
0
0
1 −2

 

n1
0
0
0
1

 
 n2   0
0
0
0
 
H=
 ..  =  .
 .   ..


nN +1
0
0
0
0

0
0
0
0
0
0
0
0

q3
0
1
−2
1

...
···
···
···
···
...

qN
0
0
0
0

s1
0
0
0
0

0
0
0

···
···
···

1
−2
1

0
1
−2

s2

0
0


0

0

.. 
.


0

0
1.

(A.9)

Consider the conical combination
m = n1 +

N
+1
X

h
i
(2k − 1)nk = · · · = 1 1 0 · · · 0 −(2N + 3) 2N + 1 .

(A.10)

k=2

This spans the relevant null space (see algorithm 1):
p · m = (−2N − 1, −1) + (0, 1) − (2N + 3)(0, 0) + (2N + 1)(1, 0) = 0.

(A.11)

Since the null space is 1D, we have thus shown that (in this case), the m ∈ coni(HTi ) is
expressible as a conical combination of n ∈ coni(H).
Thus, in every 2-triangle case, the derived secondary cone hyperplane is expressible in
terms of constraints in algorithm 2.
A.2.4

All together

In each case of fig. 6, we saw that the associated hyperplane normal either did not occur in
the support of the secondary subfan of fine triangulations, or that it was expressible as the
conical hull of hyperplane normals in algorithm 2. This thus shows the desired inclusion,
that coni(G) ⊆ coni(H).

24

